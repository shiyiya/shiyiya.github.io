<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="renderer" content="webkit">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <link rel="shortcut icon" href="/favicon.png" type="image/png">
    <title>初探 Progressive Web App - 佚名</title>
    
      
<link rel="stylesheet" href="/css/style.css">

      
<link rel="stylesheet" href="/libs/highlight/styles/monokai-sublime.css">

      
<link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css">

      
<link rel="stylesheet" href="/libs/zpix/zpix.css">

      
<script src="/js/theme.js"></script>

    
<meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="佚名" type="application/atom+xml">
</head>

<body id="bodyx" path="archives/pwa-introduction/">
    <div class="hd posts">
    <a class="back" href="javascript:void(0);" target="_self"><i class="fa fa-reply replay-btn" aria-hidden="true"></i></a>
    <h1 class="post-title">初探 Progressive Web App</h1>
    <hr>

    
        <div class="outdated-notify">
            本文发布于 <span class="num">-</span> 天前，文中所描述的信息可能已发生改变或是过时，请注意辨别
        </div>
    

    <div class="post-content">
        <h2>它是什么 ？</h2><p>Progressive Web App, 简称 PWA，是提升 Web App 的体验的一种新方法，能给用户（类）原生应用的体验。</p>
<p>PWA 的主要特点:</p>
<ul>
<li>可靠 - 即使在不稳定的网络环境下，也能瞬间加载并展现</li>
<li>体验 - 快速响应，并且有平滑的动画响应用户的操作</li>
<li>粘性 - 像设备上的原生应用，具有沉浸式的用户体验，用户可以添加到桌面</li>
</ul>
<span id="more"></span>

<h2>创建 Web App Manifest</h2><p>PWA 添加至桌面的功能实现依赖于 manifest.json，所以我们首先来创建它。</p>
<p>用于添加到桌面的描述等，提升 PWA 从主屏幕启动时的应用体验。<br>如：</p>
<pre><code class="json">&#123;
  &quot;short_name&quot;: &quot;短名称&quot;, //用于主屏幕显示
  &quot;name&quot;: &quot;这是一个完整名称&quot;, //用于安装横幅显示
  &quot;background_color&quot;: &quot;#0000ff&quot;, //启动背景颜色
  &quot;display&quot;: &quot;standalone&quot;, //启动显示类型
  &quot;theme_color&quot;: &quot;blue&quot;, //主题颜色, 启动画面上状态栏、内容页中状态栏、地址栏的颜色，会被 theme_color 所影响。
  &quot;icons&quot;: [
    &#123;
      &quot;src&quot;: &quot;images/icon/icon-48.png&quot;,
      &quot;type&quot;: &quot;image/png&quot;,
      &quot;sizes&quot;: &quot;48x48&quot;
    &#125;,
    &#123;
      &quot;src&quot;: &quot;images/icon/icon-64.png&quot;,
      &quot;sizes&quot;: &quot;64x64&quot;
    &#125;,
    &#123;
      &quot;src&quot;: &quot;images/icon/icon-114.png&quot;,
      &quot;type&quot;: &quot;image/png&quot;,
      &quot;sizes&quot;: &quot;114x114&quot;
    &#125;,
    &#123;
      &quot;src&quot;: &quot;images/icon/icon-128.png&quot;,
      &quot;type&quot;: &quot;image/png&quot;,
      &quot;sizes&quot;: &quot;128x128&quot;
    &#125;
  ],
  &quot;start_url&quot;: &quot;/?from=pwa&quot;
&#125;
</code></pre>
<p>应用安装提醒<br>浏览器在 PWA 站点满足以下条件时会自动显示横幅，提醒你将站点添加到桌面：</p>
<ul>
<li><p>站点部署 manifest.json，该文件需配置如下属性：</p>
<ul>
<li>short_name （用于主屏幕显示）</li>
<li>name （用于安装横幅显示）</li>
<li>icons （其中必须包含一个 mime 类型为 image/png 的图标声明）</li>
<li>start_url （应用启动地址）</li>
<li>display （必须为 standalone 或 fullscreen）</li>
</ul>
</li>
<li><p>站点注册 Service Worker。</p>
</li>
<li><p>站点支持 HTTPS 访问。</p>
</li>
<li><p>站点在同一浏览器中被访问至少两次，两次访问间隔至少为 5 分钟</p>
</li>
<li><p>如果满足以上条件浏览器也提供了一些事件接口供网站开发者使用。</p>
</li>
</ul>
<h3>判断用户是否安装此应用</h3><p>beforeinstallprompt 事件返回一个名为 userChoice 的 Promise 对象，并在当用户对横幅进行操作时进行解析。promise 会返回属性 outcome，该属性的值为 dismissed 或 accepted，如果用户将网页添加到主屏幕，则返回 accepted。</p>
<pre><code class="javascript">window.addEventListener(&#39;beforeinstallprompt&#39;, function (e) &#123;
  e.userChoice.then(function (choiceResult) &#123;
    if (choiceResult.outcome === &#39;dismissed&#39;) &#123;
      console.log(&#39;用户取消安装应用&#39;)
    &#125; else &#123;
      console.log(&#39;用户安装了应用&#39;)
    &#125;
  &#125;)
&#125;)
</code></pre>
<h2>添加离线缓存</h2><p>PWA 主要解决的就是离线访问，即使再没网的情况下也能查看之前访问过的资源，实现这些功能可以使用 indexDB，service worker，localstorage 等，下面我们使用 SW 实现。</p>
<h2>什么是 Service Worker</h2><p>基于 Cache API 实现，主要用来做持久的离线缓存。在你首次访问网站，将部分资源离线缓存，在你网络不好或者无网状态下将会加载这些缓存资源。</p>
<h2>注册 Service Worker</h2><pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;body&gt;&lt;/body&gt;
  &lt;script&gt;
    if (&#39;serviceWorker&#39; in navigator) &#123;
      navigator.serviceWorker
        .register(&#39;sw.js&#39;, &#123; scope: &#39;/&#39; &#125;)
        .then(function (reg) &#123;
          console.log(&#39;Registration succeeded. Scope is &#39; + reg.scope)
        &#125;)
        .catch(function (error) &#123;
          console.log(&#39;Registration failed with &#39; + error)
        &#125;)
    &#125;
  &lt;/script&gt;
&lt;/html&gt;
</code></pre>
<p>注册成功后在控制台 Application -&gt; Service Workers 将看到：<br>在你的 service worker 注册之后，浏览器会尝试为你的页面或站点安装并激活它。</p>
<h2>Service Worker 编写</h2><p>service worker 主要有三个事件： install，activate 和 fetch。</p>
<h3>Install</h3><p>install： 这个状态发生在 Service Worker 注册之后，表示开始安装，触发 install 事件回调指定一些静态资源进行离线缓存<br>添加 sw.js ,缓存网站静资源：</p>
<pre><code class="javascript">const cacheVersion = &#39;2018518&#39;
const staticeCacheName = &#39;static&#39; + cacheVersion //缓存版本（分组）
const cacheList = [
  //缓存列表
  &#39;/&#39;,
  &#39;img.png&#39;,
]
self.addEventListener(&#39;install&#39;, function (event) &#123;
  console.log(&#39;service worker: install&#39;)
  event.waitUntil(
    //确保以下执行后完成 sw 安装。
    caches
      .open(staticeCacheName)
      .then(function (cache) &#123;
        return cache.addAll(cacheList)
      &#125;)
      .then(() =&gt; self.skipWaiting()) //安装阶段跳过等待，直接进入 active, 保证每次 /sw.js
  )
&#125;)
</code></pre>
<ul>
<li>event.waitUntil：执行完内部代码（缓存资源），进行 sw 安装。</li>
<li>caches.open：添加缓存版本（组）。</li>
</ul>
<p>刷新页面，你见看到资源已经被缓存。</p>
<h3>activate</h3><p>当 install 完成后， service worker 进入 active 状态，这个事件立刻执行。如果你的 service worker 已经被安装，但是刷新页面时有一个新版本的可用，新版的 service worker 会在后台安装，但是还没激活。这时候就需要删除旧版本的缓存并注册新的 sw 。</p>
<pre><code class="javascript">self.addEventListener(&#39;activate&#39;, function (event) &#123;
  console.log(&#39;service worker: activate&#39;)
  const newCaches = &#39;newCaches&#39;
  event.waitUntil(
    self.clients.claim(), //更新客户端
    caches.keys().then(function (keyList) &#123;
      return Promise.all(
        keyList.map(function (key) &#123;
          if (newCaches.indexOf(key) === -1) &#123;
            return caches.delete(key)
          &#125;
        &#125;)
      )
    &#125;)
  )
&#125;)
</code></pre>
<h3>fetch</h3><p>每次任何被 service worker 控制的资源被请求到时，都会触发 fetch 事件，这些资源包括了指定的 scope 内的文档，和这些文档内引用的其他任何资源（比如 index.html 发起了一个跨域的请求来嵌入一个图片，这个也会通过 service worker 。<br>我们可以利用它来进行监听 http 请求，更改内容。</p>
<pre><code class="javascript">self.addEventListener(&#39;fetch&#39;, function (event) &#123;
  console.log(&#39;service worker: fetch&#39;)
  event.respondWith(
    caches
      .match(event.request)
      .then(function (resp) &#123;
        if ((event.request.url = &#39;xxxxx&#39;)) &#123;
          //doSomeThing
        &#125;
        return (
          resp ||
          fetch(event.request).then(function (response) &#123;
            //↑ 如果缓存有直接返回，否则发起网络请求
            return caches.open(&#39;fetch&#39;).then(function (cache) &#123;
              //↑ 创建新本，缓存新的请求资源
              if (!(event.request.url.indexOf(&#39;http&#39;) === -1)) &#123;
                //排除 Chrome 扩展
                cache.put(event.request, response.clone()) //将新的新的请求资源推入缓存
                return response
              &#125; else &#123;
                return response
              &#125;
            &#125;)
          &#125;)
        )
      &#125;)
      .catch(function () &#123;
        return caches.match(&#39;/error.html&#39;) //没有缓存并且请求错误
      &#125;)
  )
&#125;)
</code></pre>
<h2>大公告成</h2><p>你可以尝试将本站点添加至桌面即可看到效果。</p>

    </div>

    

    <script>
        var pub_date = 1558108800000;
    </script>
</div>
    <div class="footer"
     id="footer">
    <p>
        Copyright © 2020 <a class="flink"
           href="http://shiyiya.github.io">佚名</a>
        <br>
        <label class="el-switch el-switch-green el-switch-sm"
               style="vertical-align: sub;">
            <input type="checkbox"
                   name="switch"
                   id="update_style">
            <span class="el-switch-style"></span>
        </label>
    </p>
</div>

<a href="javascript:void(0);" class="back-to-top" target="_self"></a>

<input type="hidden"
       id="web_style"
       value="white">
<input type="hidden"
       id="valine_appid"
       value="CaQKuPQDfnfPFUkTw6MMt8ME-gzGzoHsz">
<input type="hidden"
       id="valine_appKey"
       value="uWuwGS1xiIwh3zHKENc7ubyL">
<script src="https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js"></script>

  
<script src="/libs/jquery.min.js"></script>

  
<script src="/libs/highlight/highlight.pack.js"></script>

  
<script src="/js/js.js"></script>


<style type="text/css">
    .v .vlist .vcard .vhead .vsys {
        color: #3a3e4a;
    }

    .v .vlist .vcard .vh .vmeta .vat {
        color: #638fd5;
    }

    .v .vlist .vcard .vhead .vnick {
        color: #6ba1ff;
    }

    .v a {
        color: #8696b1;
    }

    .v .vlist .vcard .vhead .vnick:hover {
        color: #669bfc;
    }

    .v .vcards .vcard .vhead .vnick {
        padding-left: 1px;
    }

    .v .vcontent .vemoji {
        max-width: 30px;
    }

    .v[data-class=v] p {
        color: inherit;
    }

</style>

<!-- Load TweenLite -->
<script src="https://cdn.jsdelivr.net/npm/greensock@1.20.2/dist/TweenLite.js"></script>




<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-117481437-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-117481437-1');
</script>


</body>

</html>